# -*- coding: utf-8 -*-
import json
import sys
import openai
# Form implementation generated from reading ui file 'mukechat0.0.3.4.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QThread, pyqtSignal, Qt
from PyQt5.QtGui import QIcon, QFont
from PyQt5.QtWidgets import QApplication, QWidget, QTextEdit, QDialog, \
    QPushButton, QLineEdit
from openai.error import APIConnectionError, AuthenticationError

chat_record_file_path = '.\chat_record.txt'
conversation = []  # 聊天记忆
chat_record = []  # 聊天记录
with open(chat_record_file_path, 'r') as f:
    chat_record = json.load(f)
key = None
error_path = '.\error.txt'
with open(error_path, 'r') as e:
    key = e.read()
icon_path = '.\LOGO.png'


# def read_file():
#     global chat_record
#     is_exists = os.path.exists('chat_record_file_path')
#     print(is_exists)
#     if is_exists:
#         with open(chat_record_file_path, 'r') as f:
#             chat_record = json.load(f)


# 按钮的多线程
class SubmitThread(QThread):
    ai_re_signal = pyqtSignal(str)

    def __init__(self, target=None):  # 23.05.22 07:55
        super().__init__()
        self.ai_re_text = None
        self.prompt = ''
        self._target = target

    def ai_reply(self) -> str:
        try:
            prompt = self.prompt
            openai.api_key = key
            global conversation, chat_record
            max_history_len = 10  # 保存5个会话给chatgpt  AI记忆控制
            first_message = None
            # if first_message is None:
            #     first_message = prompt  # 存储第一句话

            conversation.append({"role": "user", "content": prompt})
            chat_record.append({"role": "user", "content": prompt})

            if len(conversation) > max_history_len:
                conversation = chat_record[-max_history_len:]  # 删掉数组第一个元素

            response = openai.ChatCompletion.create(  # 调用官方给出来的API接口获取返回值
                model="gpt-3.5-turbo",
                messages=conversation,
                temperature=1,
                max_tokens=1024,
                n=1,
                timeout=15,
                stop=None,
                top_p=0.9
            )
            # 把ai的回复消息放到列表里
            conversation.append({"role": "assistant", "content": response['choices'][0]['message']['content']})
            chat_record.append({"role": "assistant", "content": response['choices'][0]['message']['content']})
            return response['choices'][0]['message']['content']

        except APIConnectionError:
            return '请求失败！请检查网络是否畅通！大陆地区需要科学上网！'
        except KeyboardInterrupt:
            return '\n连接已经被用户手动断开'
        except AuthenticationError:
            return '请检查你的密钥是否有问题！请聚焦主窗口并通过ait+k快捷键打开密钥设置！'
        except Exception:
            return '未知错误！前联系开发人员！\nmukelee0723@Gmail.com\n我们会对被采纳的反馈给予报酬！'

    def get_user_prompt(self, prompt):  # 获取用户请求内容
        self.prompt = prompt

    def run(self) -> None:
        prompt = self.ai_reply()  # 调用接口
        self.ai_re_signal.emit(prompt)  # 把Ai回复以信号的方式传回去
        # self._target()


class ChatBox(QTextEdit):
    def addQTexEdit(self, parent: object, layout: object, obj_name='textEdit'):
        textEdit = QtWidgets.QTextEdit(parent)
        font = QtGui.QFont()
        font.setPointSize(12)
        textEdit.setFont(font)
        textEdit.setReadOnly(True)
        textEdit.setObjectName(obj_name)
        layout.addWidget(textEdit)
        return textEdit


# 主窗口UI
class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(600, 450)
        # Form.setWindowOpacity(0.9)
        # Form.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        # Form.setWindowFlag(QtCore.Qt.FramelessWindowHint)
        Form.setMinimumSize(QtCore.QSize(400, 350))
        self.verticalLayout = QtWidgets.QVBoxLayout(Form)
        self.verticalLayout.setObjectName("verticalLayout")
        self.widget = QtWidgets.QWidget(Form)
        self.widget.setObjectName("widget")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.widget)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.scrollArea = QtWidgets.QScrollArea(self.widget)
        # self.scrollArea.setStyleSheet('QScrollBar{background-color: white; border: 1px solid black;}')
        self.scrollArea.verticalScrollBar().rangeChanged.connect(  # 滚动区发生变化时，滚到滚动区最大值
            lambda: self.scrollArea.verticalScrollBar().setValue(
                self.scrollArea.verticalScrollBar().maximum()
            )
        )
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setAlignment(QtCore.Qt.AlignLeading | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 408, 280))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        # 水平布局
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents)
        self.verticalLayout_2.setObjectName("verticalLayout_2")

        self.verticalLayout_2.addStretch(1)  # 类似弹簧

        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.horizontalLayout_2.addWidget(self.scrollArea)
        self.verticalLayout.addWidget(self.widget)
        self.widget_2 = QtWidgets.QWidget(Form)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_2.sizePolicy().hasHeightForWidth())
        self.widget_2.setSizePolicy(sizePolicy)
        self.widget_2.setMinimumSize(QtCore.QSize(0, 105))
        self.widget_2.setMaximumSize(QtCore.QSize(16777215, 130))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.widget_2.setFont(font)
        self.widget_2.setObjectName("widget_2")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.widget_2)
        self.horizontalLayout.setObjectName("horizontalLayout")

        # 输入框
        self.textEdit_input = myTextEdit(self.widget_2, self)
        self.textEdit_input.setPlaceholderText('请输入……')
        self.textEdit_input.setMinimumSize(QtCore.QSize(0, 86))
        self.textEdit_input.viewport().setProperty("cursor", QtGui.QCursor(QtCore.Qt.IBeamCursor))
        self.textEdit_input.setObjectName("textEdit_input")
        self.horizontalLayout.addWidget(self.textEdit_input)

        # 提交按钮
        self.pushButton = QtWidgets.QPushButton(self.widget_2)
        self.pushButton.clicked.connect(self.start_btn_thread)  # 绑定事件
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButton.sizePolicy().hasHeightForWidth())
        self.pushButton.setSizePolicy(sizePolicy)
        self.pushButton.setMinimumSize(QtCore.QSize(70, 86))
        self.pushButton.setFont(font)
        self.pushButton.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.pushButton.setObjectName("pushButton")
        self.horizontalLayout.addWidget(self.pushButton)
        self.verticalLayout.addWidget(self.widget_2)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    # 添加聊天框，开启请求线程
    def start_btn_thread(self):
        user_text = self.textEdit_input.toPlainText()
        if user_text != '':
            # 创建文字聊天气泡
            self.chat_box_user = ChatBox.addQTexEdit(QTextEdit, parent=self.scrollAreaWidgetContents,
                                                     layout=self.verticalLayout_2)
            self.chat_box_user.setStyleSheet('background:pink;')
            self.chat_box_user.setText(user_text)
            self.textEdit_input.setText('')  # 清空

            self.chat_box_ai = ChatBox.addQTexEdit(QTextEdit, parent=self.scrollAreaWidgetContents,
                                                   layout=self.verticalLayout_2)
            # print(chat_box_user.frameSize())
            # 创建线程
            self.thread = SubmitThread()
            self.thread.get_user_prompt(user_text)
            self.thread.ai_re_signal.connect(self.get_ai_re)  # 绑定信号的槽函数
            # print(self.thread)

            self.thread.start()
            # print(self.text)

    def get_ai_re(self, text):  # 信号的槽函数
        self.chat_box_ai.setText(text)  # 把子线程发过来的东西在主线UI上打印出来（通过线程通讯处理），子线程上操作主线程UI会出现闪退现象，这是由于Qt存在兼容问题

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "MukeChat"))
        Form.setWindowIcon(QIcon(icon_path))
        self.pushButton.setText(_translate("Form", "发送"))


# mukechat主窗口UI在封装对象
class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.win_ui = Ui_Form()
        self.win_ui.setupUi(self)
        # 初始化数据
        self.init_record_data()
        # self.win_ui.scrollAreaWidgetContents

    # 初始化聊天记录，把之前的聊天记录加载上来
    def init_record_data(self):
        for item in chat_record:
            if item['role'] == 'role':
                self.win_ui.user_record = ChatBox.addQTexEdit(QTextEdit, parent=self.win_ui.scrollAreaWidgetContents,
                                                              layout=self.win_ui.verticalLayout_2)
                self.win_ui.user_record.setText(item['content'])
            else:
                self.win_ui.AI_record = ChatBox.addQTexEdit(QTextEdit, parent=self.win_ui.scrollAreaWidgetContents,
                                                            layout=self.win_ui.verticalLayout_2)
                self.win_ui.AI_record.setText(item['content'])

    def resizeEvent(self, a0: QtGui.QResizeEvent) -> None:
        pass

    def keyPressEvent(self, a0: QtGui.QKeyEvent) -> None:  # 主窗口监听
        # alt+k 密钥快捷设置
        if a0.modifiers() == QtCore.Qt.KeyboardModifier.AltModifier and a0.key() == QtCore.Qt.Key_K:
            # self.start_setting_thread()
            self.dialog = QDialog()
            self.dialog.setWindowIcon(QIcon(icon_path))
            self.dialog.resize(500, 300)
            self.layout = QtWidgets.QGridLayout(self.dialog)
            # 输入框
            self.key_edit = QLineEdit(self.dialog)
            self.key_edit.setMinimumSize(100, 50)
            font = QFont()
            font.setPointSize(12)
            self.key_edit.setFont(font)
            self.key_edit.setPlaceholderText('请输入你的密钥')
            self.key_edit.setEchoMode(QtWidgets.QLineEdit.Password)
            self.layout.addWidget(self.key_edit)
            # 提交按钮
            self.btn = QPushButton("确定", self.dialog)
            self.btn.clicked.connect(self.save_key)  # 保存密钥
            self.layout.addWidget(self.btn)
            # btn.move(50, 50)
            self.dialog.setWindowTitle("设置")
            self.dialog.setWindowModality(Qt.ApplicationModal)
            self.dialog.exec_()

    def save_key(self):  # 保存密钥
        global key
        key = self.key_edit.text()  # 获取密钥
        with open(error_path, 'w') as e:
            e.write(key)

        self.dialog.close()  # 关闭密钥窗口

    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:  # 重写窗口关闭事件，关闭前保存聊天数据
        with open(chat_record_file_path, 'w') as file:
            json.dump(chat_record, file)


# 继承了keyPressEvent的QTextEdit，可以进行键盘监听
class myTextEdit(QtWidgets.QTextEdit):
    def __init__(self, parent, current_class_obj=None):
        QtWidgets.QTextEdit.__init__(self)
        self.parent = parent
        self.current_class_obj = current_class_obj

    def keyPressEvent(self, event):  # 文本框监听
        QtWidgets.QTextEdit.keyPressEvent(self, event)  # 继承监听事件
        if event.key() == Qt.Key_Return:
            if event.key() == Qt.Key_Return:
                if self.toPlainText() != '':
                    self.current_class_obj.start_btn_thread()
                    # self.parent.dealMessage()


if __name__ == '__main__':
    # read_file()
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    app.exec()
